name: Deploy to Server (Astro)

on:
  push:
    branches: [main, preview]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: "server-${{ github.ref }}"
  cancel-in-progress: true

env:
  RSYNC_PERMS: "Du=rwx,Dgo=rx,Fu=rw,Fgo=r"  # dirs=755, files=644

jobs:
  precheck_server:
    name: "Precheck: required secrets & SSH connectivity"
    runs-on: ubuntu-latest
    outputs:
      ready: ${{ steps.final.outputs.ready }}
      reason: ${{ steps.final.outputs.reason }}
    steps:
      - name: "Check presence of required secrets"
        id: presence
        shell: bash
        env:
          SSH_HOST:         ${{ secrets.SSH_HOST }}
          SSH_USER:         ${{ secrets.SSH_USER }}
          SSH_PORT:         ${{ secrets.SSH_PORT || '22' }}
          SSH_PRIVATE_KEY:  ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_KNOWN_HOSTS:  ${{ secrets.SSH_KNOWN_HOSTS }}
          SITE_URL_MAIN:    ${{ secrets.SITE_URL_MAIN }}
          SITE_URL_PREVIEW: ${{ secrets.SITE_URL_PREVIEW }}
          DOCROOT_MAIN:     ${{ secrets.DEPLOY_MAIN_DOCROOT_PATH }}
          DOCROOT_PREV:     ${{ secrets.DEPLOY_PREVIEW_DOCROOT_PATH }}
          BACKUPS_DIR:      ${{ secrets.BACKUPS_DIR_PATH }}
        run: |
          set -euo pipefail
          missing=()
          for v in SSH_HOST SSH_USER SSH_PRIVATE_KEY SITE_URL_MAIN SITE_URL_PREVIEW DOCROOT_MAIN DOCROOT_PREV BACKUPS_DIR; do
            if [ -z "${!v:-}" ]; then missing+=("$v"); fi
          done
          if [ ${#missing[@]} -gt 0 ]; then
            echo "ok=false"   >> "$GITHUB_OUTPUT"
            echo "reason=Missing secrets: ${missing[*]}" >> "$GITHUB_OUTPUT"
          else
            echo "ok=true"    >> "$GITHUB_OUTPUT"
          fi

      - name: "Check SSH key (normalize) & connectivity (3 tries)"
        id: ssh
        if: ${{ steps.presence.outputs.ok == 'true' }}
        shell: bash
        env:
          SSH_HOST:         ${{ secrets.SSH_HOST }}
          SSH_USER:         ${{ secrets.SSH_USER }}
          SSH_PORT:         ${{ secrets.SSH_PORT || '22' }}
          SSH_PRIVATE_KEY:  ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_KNOWN_HOSTS:  ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          set -euo pipefail
          install -m 700 -d ~/.ssh

          # Normalize CRLF -> LF and ensure trailing newline
          printf "%s" "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_deploy
          tail -c1 ~/.ssh/id_deploy | od -An -t x1 | grep -q '0a' || echo >> ~/.ssh/id_deploy
          chmod 600 ~/.ssh/id_deploy

          # Validate private key can be loaded
          if ! ssh-keygen -y -f ~/.ssh/id_deploy >/dev/null 2>&1; then
            echo "ok=false"   >> "$GITHUB_OUTPUT"
            echo "reason=Invalid SSH_PRIVATE_KEY (format or passphrase)" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # known_hosts (strict)
          if [ -n "${SSH_KNOWN_HOSTS:-}" ]; then
            printf "%s\n" "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          else
            ssh-keyscan -p "$SSH_PORT" "$SSH_HOST" > ~/.ssh/known_hosts
          fi

          # Connectivity using ONLY this key (3 tries)
          success=false
          for i in 1 2 3; do
            if ssh -p "$SSH_PORT" -o BatchMode=yes -o ConnectTimeout=10 \
                  -o StrictHostKeyChecking=yes -o IdentitiesOnly=yes \
                  -i ~/.ssh/id_deploy "$SSH_USER@$SSH_HOST" "echo ok" >/dev/null 2>&1; then
              success=true; break
            fi
            echo "SSH attempt $i failed; retrying in 5s..." >&2
            sleep 5
          done

          if $success; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "reason=SSH connection failed after retries (host/user/port/key/known_hosts)" >> "$GITHUB_OUTPUT"
          fi

      - name: "Finalize precheck result"
        id: final
        shell: bash
        env:
          PRESENCE_OK:     ${{ steps.presence.outputs.ok }}
          PRESENCE_REASON: ${{ steps.presence.outputs.reason }}
          SSH_OK:          ${{ steps.ssh.outputs.ok }}
          SSH_REASON:      ${{ steps.ssh.outputs.reason }}
        run: |
          set -euo pipefail
          ready=true
          reason=""
          if [ "${PRESENCE_OK:-false}" != "true" ]; then
            ready=false
            reason="${PRESENCE_REASON:-missing secrets}"
          elif [ "${SSH_OK:-false}" != "true" ]; then
            ready=false
            reason="${SSH_REASON:-ssh failed}"
          fi
          echo "ready=$ready"   >> "$GITHUB_OUTPUT"
          echo "reason=$reason" >> "$GITHUB_OUTPUT"
          if [ "$ready" != "true" ]; then
            echo "::warning::Server deploy precheck failed: $reason"
          fi

  build:
    if: ${{ needs.precheck_server.outputs.ready == 'true' }}
    needs: precheck_server
    runs-on: ubuntu-latest
    outputs:
      site:          ${{ steps.vars.outputs.site }}
      deploy_target: ${{ steps.vars.outputs.deploy_target }}
      is_main:       ${{ steps.vars.outputs.is_main }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Select SITE and target docroot by branch (from Secrets)"
        id: vars
        shell: bash
        env:
          SITE_URL_MAIN:     ${{ secrets.SITE_URL_MAIN }}
          SITE_URL_PREVIEW:  ${{ secrets.SITE_URL_PREVIEW }}
          DOCROOT_MAIN:      ${{ secrets.DEPLOY_MAIN_DOCROOT_PATH }}
          DOCROOT_PREVIEW:   ${{ secrets.DEPLOY_PREVIEW_DOCROOT_PATH }}
        run: |
          set -euo pipefail
          if [ "${GITHUB_REF_NAME}" = "main" ]; then
            echo "site=${SITE_URL_MAIN}"            >> "$GITHUB_OUTPUT"
            echo "deploy_target=${DOCROOT_MAIN}"    >> "$GITHUB_OUTPUT"
            echo "is_main=true"                     >> "$GITHUB_OUTPUT"
          else
            echo "site=${SITE_URL_PREVIEW}"         >> "$GITHUB_OUTPUT"
            echo "deploy_target=${DOCROOT_PREVIEW}" >> "$GITHUB_OUTPUT"
            echo "is_main=false"                    >> "$GITHUB_OUTPUT"
          fi

      - name: "Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: "Install Dependencies"
        run: npm install

      - name: "Build (Astro)"
        run: npm run build
        env:
          BASE_PATH: /
          SITE: ${{ steps.vars.outputs.site }}

      - name: "Upload build artifact"
        uses: actions/upload-artifact@v4
        with:
          name: site-dist
          path: ./dist
          if-no-files-found: error
          retention-days: 7

  deploy:
    if: ${{ needs.precheck_server.outputs.ready == 'true' }}
    needs: [precheck_server, build]
    runs-on: ubuntu-latest
    steps:
      - name: "Download build artifact"
        uses: actions/download-artifact@v4
        with:
          name: site-dist
          path: ./dist

      - name: "Prepare SSH (key + known_hosts)"
        shell: bash
        env:
          SSH_HOST:         ${{ secrets.SSH_HOST }}
          SSH_PORT:         ${{ secrets.SSH_PORT || '22' }}
          SSH_PRIVATE_KEY:  ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_KNOWN_HOSTS:  ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          set -euo pipefail
          install -m 700 -d ~/.ssh
          printf "%s" "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_deploy
          tail -c1 ~/.ssh/id_deploy | od -An -t x1 | grep -q '0a' || echo >> ~/.ssh/id_deploy
          chmod 600 ~/.ssh/id_deploy
          if [ -n "${SSH_KNOWN_HOSTS:-}" ]; then
            printf "%s\n" "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          else
            ssh-keyscan -p "$SSH_PORT" "$SSH_HOST" > ~/.ssh/known_hosts
          fi

      - name: "Resolve deploy_target (fallback-safe)"
        id: target
        shell: bash
        env:
          FROM_OUTPUT:     ${{ needs.build.outputs.deploy_target }}
          BRANCH:          ${{ github.ref_name }}
          DOCROOT_MAIN:    ${{ secrets.DEPLOY_MAIN_DOCROOT_PATH }}
          DOCROOT_PREVIEW: ${{ secrets.DEPLOY_PREVIEW_DOCROOT_PATH }}
        run: |
          set -euo pipefail
          val="${FROM_OUTPUT:-}"
          if [ -z "$val" ]; then
            if [ "${BRANCH}" = "main" ]; then
              val="${DOCROOT_MAIN:-}"
            else
              val="${DOCROOT_PREVIEW:-}"
            fi
          fi
          if [ -z "$val" ]; then
            echo "::error::Resolved deploy_target is empty (check DOCROOT secrets and branch)"; exit 1
          fi
          echo "deploy_target=$val" >> "$GITHUB_OUTPUT"

      - name: "Ensure docroot exists (remote, 3 tries)"
        shell: bash
        env:
          SSH_HOST:      ${{ secrets.SSH_HOST }}
          SSH_USER:      ${{ secrets.SSH_USER }}
          SSH_PORT:      ${{ secrets.SSH_PORT || '22' }}
          DEPLOY_TARGET: ${{ steps.target.outputs.deploy_target }}
        run: |
          set -euo pipefail
          ssh_retry() {
            for i in 1 2 3; do
              if ssh -i ~/.ssh/id_deploy -p "$SSH_PORT" -o StrictHostKeyChecking=yes -o IdentitiesOnly=yes \
                   "$SSH_USER@$SSH_HOST" "$1"; then
                return 0
              fi
              echo "SSH attempt $i failed; retrying in 5s..." >&2
              sleep 5
            done
            return 1
          }
          ssh_retry "mkdir -p '${DEPLOY_TARGET}'"

      - name: "Safety backup on remote host (guarded, 3 tries + retention)"
        shell: bash
        env:
          SSH_HOST:      ${{ secrets.SSH_HOST }}
          SSH_USER:      ${{ secrets.SSH_USER }}
          SSH_PORT:      ${{ secrets.SSH_PORT || '22' }}
          DEPLOY_TARGET: ${{ steps.target.outputs.deploy_target }}
          BACKUPS_DIR:   ${{ secrets.BACKUPS_DIR_PATH }}
          BACKUPS_MAX:   ${{ secrets.BACKUPS_MAX }}
        run: |
          set -euo pipefail
          ssh_retry() {
            for i in 1 2 3; do
              if ssh -i ~/.ssh/id_deploy -p "$SSH_PORT" -o StrictHostKeyChecking=yes -o IdentitiesOnly=yes \
                   "$SSH_USER@$SSH_HOST" "$1"; then
                return 0
              fi
              echo "SSH attempt $i failed; retrying in 5s..." >&2
              sleep 5
            done
            return 1
          }

          cmd="
            DOCROOT='${DEPLOY_TARGET}' BACKUPS_DIR='${BACKUPS_DIR}' BACKUPS_MAX='${BACKUPS_MAX}' bash -lc '
              set -euo pipefail
              ts=\$(date +%F)

              # Validate inputs
              if [ -z \"\${DOCROOT:-}\" ] || [ -z \"\${BACKUPS_DIR:-}\" ]; then
                echo \"ERROR: DOCROOT/BACKUPS_DIR cannot be empty\" >&2; exit 1
              fi
              case \"\$DOCROOT\" in /*) ;; *) echo \"ERROR: DOCROOT must be absolute\"; exit 1;; esac
              case \"\$BACKUPS_DIR\" in /*) ;; *) echo \"ERROR: BACKUPS_DIR must be absolute\"; exit 1;; esac
              if [ \"\$DOCROOT\" = \"/\" ]; then
                echo \"ERROR: Refusing to backup \"/\"\"; exit 1
              fi

              base=\$(basename \"\$DOCROOT\")
              DEST=\"\$BACKUPS_DIR/\${base}_\${ts}\"

              # Forbid destination inside docroot
              case \"\$DEST/\" in
                \"\$DOCROOT\"/*) echo \"ERROR: Backup destination \\\"\$DEST\\\" must NOT be inside docroot \\\"\$DOCROOT\\\"\"; exit 1;;
              esac

              mkdir -p \"\$DEST\"

              # Actual backup
              rsync -a --delete --human-readable --one-file-system \
                \"\$DOCROOT/\" \"\$DEST/\"

              # Retention: keep only most recent BACKUPS_MAX (if >=1)
              if [ -n \"\${BACKUPS_MAX:-}\" ] && [ \"\${BACKUPS_MAX}\" -ge 1 ] 2>/dev/null; then
                all=\$(find \"\$BACKUPS_DIR\" -maxdepth 1 -mindepth 1 -type d -name \"\${base}_*\" | sort)
                count=\$(printf \"%s\n\" \"\$all\" | sed \"/^\\s*$/d\" | wc -l || true)
                if [ \"\$count\" -gt \"\$BACKUPS_MAX\" ]; then
                  to_delete=\$((count - BACKUPS_MAX))
                  printf \"%s\n\" \"\$all\" | head -n \"\$to_delete\" | xargs -r -I{} rm -rf -- \"{}\"
                fi
              fi
            '
          "
          ssh_retry "$cmd"

      - name: "Deploy via rsync (preserve EXCLUDE_PATHS only on main, 3 tries)"
        shell: bash
        env:
          SSH_HOST:      ${{ secrets.SSH_HOST }}
          SSH_USER:      ${{ secrets.SSH_USER }}
          SSH_PORT:      ${{ secrets.SSH_PORT || '22' }}
          DEPLOY_TARGET: ${{ steps.target.outputs.deploy_target }}
          IS_MAIN:       ${{ needs.build.outputs.is_main }}
          EXCLUDE_PATHS: ${{ secrets.EXCLUDE_PATHS }}   # e.g. "beta, v1"
          RSYNC_PERMS:   ${{ env.RSYNC_PERMS }}
        run: |
          set -euo pipefail
          RSYNC_OPTS="-az --delete --human-readable --chmod=$RSYNC_PERMS"
          if [ "$IS_MAIN" = "true" ] && [ -n "${EXCLUDE_PATHS:-}" ]; then
            IFS=',' read -ra EXS <<< "$EXCLUDE_PATHS"
            for raw in "${EXS[@]}"; do
              x="$(echo "$raw" | xargs)"  # trim
              [ -n "$x" ] && RSYNC_OPTS="$RSYNC_OPTS --exclude=$x/"
            done
          fi

          rsync_retry() {
            for i in 1 2 3; do
              if rsync $RSYNC_OPTS \
                   -e "ssh -i ~/.ssh/id_deploy -p $SSH_PORT -o StrictHostKeyChecking=yes -o IdentitiesOnly=yes" \
                   ./dist/ "$SSH_USER@$SSH_HOST:${DEPLOY_TARGET}/"; then
                return 0
              fi
              echo "rsync attempt $i failed; retrying in 5s..." >&2
              sleep 5
            done
            return 1
          }
          rsync_retry

      - name: "(Optional) chown owner/group on destination (3 tries)"
        shell: bash
        env:
          SSH_HOST:      ${{ secrets.SSH_HOST }}
          SSH_USER:      ${{ secrets.SSH_USER }}
          SSH_PORT:      ${{ secrets.SSH_PORT || '22' }}
          DEPLOY_TARGET: ${{ steps.target.outputs.deploy_target }}
          DEPLOY_OWNER:  ${{ secrets.DEPLOY_OWNER }}
          DEPLOY_GROUP:  ${{ secrets.DEPLOY_GROUP }}
        run: |
          set -euo pipefail
          if [ -z "${DEPLOY_OWNER:-}" ] || [ -z "${DEPLOY_GROUP:-}" ]; then
            echo "No DEPLOY_OWNER/GROUP provided; skipping chown."
            exit 0
          fi
          ssh_retry() {
            for i in 1 2 3; do
              if ssh -i ~/.ssh/id_deploy -p "$SSH_PORT" -o StrictHostKeyChecking=yes -o IdentitiesOnly=yes \
                   "$SSH_USER@$SSH_HOST" "chown -R '${DEPLOY_OWNER}:${DEPLOY_GROUP}' '${DEPLOY_TARGET}'"; then
                return 0
              fi
              echo "SSH attempt $i failed; retrying in 5s..." >&2
              sleep 5
            done
            return 1
          }
          ssh_retry